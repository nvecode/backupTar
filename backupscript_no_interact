#!/bin/bash

#BACKUP_VAR
BACKUP_STORAGE_DIR=$2
BACKUP_STORAGE_NAME=$3
SOURCE_BACKUP=$4
BACKUP_FULL_COUNT=$(( $5 * 2 ))
BACKUP_INCR_COUNT=$(( $6 * 2 ))

#RESTORE_VAR
RESTORE_STORAGE_DIR=$3

#=======================Неизменяемые поля=======================#
BACKUP_DIR_DATA=${BACKUP_STORAGE_DIR}/data
BACKUP_DIR_DATA_LOG=${BACKUP_STORAGE_DIR}/logs
BACKUP_SNAR_DIR=${BACKUP_STORAGE_DIR}/snar
BACKUP_DATE=$(date +'%d%m%Y')
BACKUP_TIME=$(date +'%H%M%S')
BACKUP_FILENAME=${BACKUP_STORAGE_NAME}_${BACKUP_DATE}_${BACKUP_TIME}

#Функция логирования
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

#Функция вывода информации по скрипту
show_help() {
    cat << EOF
Использование:
  ./backupscript incr <backup_storage_dir> <backup_storage_name> <source_backup> <backup_full_count> <backup_incr_count>
  ./backupscript full <backup_storage_dir> <backup_storage_name> <source_backup> <backup_full_count> <backup_incr_count>
  ./backupscript restore <backup_storage_dir> <destination_restore_data>

Параметры для резервного копирования:
  backup_storage_dir    - директория для хранения бэкапов
  backup_storage_name   - имя бэкапа
  source_backup         - директория для резервного копирования
  backup_full_count     - количество хранимых полных бэкапов (целое число)
  backup_incr_count     - количество хранимых инкрементальных бэкапов (целое число)

Параметры для восстановления:
  backup_storage_dir        - директория для хранения бэкапов
  destination_restore_data  - директория для восстановления

Примеры:
  ./backupscript incr /backups mybackup /home/user 3 5
  ./backupscript full /backups mybackup /home/user 3 5
  ./backupscript restore /backups /restored_data
EOF
}

#Функция поиска старых бэкапов или логов
search_old_backup_or_log() {
    #В функцию передаются: 1) Тип бэкапа: инкрементный или полный, 2) Тип файла: лог, бэкап или snar
    local typeBackup=$1
    local typeFile=$2
    local file_count=""
    local search_dir=""

    #Проверка на тип переданного файла и подсчёт количество файлов в директории
    if [ "$typeFile" == "backup" ]; then
        search_dir=$BACKUP_DIR_DATA
        file_count=$(ls $BACKUP_DIR_DATA | grep $typeBackup | wc -l)
    elif [ "$typeFile" == "log" ]; then
        search_dir=$BACKUP_DIR_DATA_LOG
        file_count=$(ls $BACKUP_DIR_DATA_LOG | grep $typeBackup | wc -l)
    elif [ "$typeFile" == "snar" ]; then
        search_dir=$BACKUP_SNAR_DIR
        file_count=$(ls $BACKUP_SNAR_DIR | grep $typeBackup | wc -l)
    fi

    #Если количество файлов больше 0, то для полного бэкапа вывести все нужные файлы
    if [ -n "$file_count" ]; then
        #Для FULL
        if [ "$typeBackup" == "full" ]; then
            if [ "$file_count" -gt $BACKUP_FULL_COUNT ]; then
                find $search_dir -maxdepth 1 -type f -name '*full*' | sort -n | head -n 1
            fi
        
        #Для INCR
        elif [ "$typeBackup" == "incr" ]; then
            if [ "$file_count" -gt $BACKUP_INCR_COUNT ]; then
                find $search_dir -maxdepth 1 -type f -name '*incr*' | sort -n | head -n 1
            fi
        
        #Для SNAR
        elif [ "$typeBackup" == "full" ]; then
            if [ "$file_count" -gt $BACKUP_FULL_COUNT ]; then
                find $search_dir -maxdepth 1 -type f -name '*$BACKUP_FILENAME*' | sort -n | head -n 1
            fi
        fi
    fi
}

#Функция удаления инкрементных файлов по времени модификации
remove_old_file_incr_or_log() {
    local old_file_backup_or_log=$1
    local folder_old_file_backup_or_log=$2

    # Получаем время модификации старого файла (в секундах с эпохи)
    old_file_mtime=$(stat -c %Y "$old_file_backup_or_log")
    
    # Удаляем инкрементные файлы, созданные раньше
    find "$folder_old_file_backup_or_log" -name "*incr*" -type f | while read -r incr_file; do
        file_mtime=$(stat -c %Y "$incr_file")
        if [ "$file_mtime" -lt "$old_file_mtime" ]; then
            echo "Удаляем: $(basename "$incr_file")"
            rm -f "$incr_file"
        fi
    done
}

#Функция создания инкрементных копий
backup_increment() {
    if [[ "$(ls $BACKUP_DIR_DATA | grep full | wc -l)" > 0 ]]; then
        #Проверка наличия последнего snar файла
        if [ -f "$BACKUP_SNAR_DIR/last_backup.snar" ]; then
            BACKUP_SNAR=$(cat "$BACKUP_SNAR_DIR/last_backup.snar")
        else
            echo "Файл SNAR для последнего запущенного полного бэкапа не найден"
            exit 1
        fi
        
        #Выполнение инкрементного бэкапа
        tar -g $BACKUP_SNAR -czvf $BACKUP_DIR_DATA/${BACKUP_FILENAME}_incr.tar.gz -C $SOURCE_BACKUP . &>$BACKUP_DIR_DATA_LOG/${BACKUP_FILENAME}_incr.log
        if [ $? -eq 0 ]; then
            #Находим бэкап или файлы, старше нужных POINT
            old_file_backup_incr=$(search_old_backup_or_log incr backup)
            old_file_log_backup_incr=$(search_old_backup_or_log incr log)

            #Удаляем найденные файлы бэкап или логов
            rm -f $old_file_backup_incr
            rm -f $old_file_log_backup_incr
        fi
    else
        echo "Необходимо сначала выполнить полный бэкап"
        exit 1
    fi
}

#Функция создания полных копий
backup_full() {
    BACKUP_SNAR="$BACKUP_SNAR_DIR/${BACKUP_STORAGE_NAME}_${BACKUP_DATE}_${BACKUP_TIME}_full.snar"
    echo "$BACKUP_SNAR" > "$BACKUP_SNAR_DIR/last_backup.snar"
    
    #Выполнение полного бэкапа
    tar -g $BACKUP_SNAR -czvf $BACKUP_DIR_DATA/${BACKUP_FILENAME}_full.tar.gz -C $SOURCE_BACKUP . &>$BACKUP_DIR_DATA_LOG/${BACKUP_FILENAME}_full.log
    if [ $? -eq 0 ]; then
        #Находим бэкап или файлы, старше нужных POINT
        old_file_backup_full=$(search_old_backup_or_log full backup)
        old_file_log_backup_full=$(search_old_backup_or_log full log)
        old_file_snar_backup_full=$(search_old_backup_or_log full snar)

        #Удаляем найденные файлы бэкап или логов
        rm -f $old_file_backup_full
        rm -f $old_file_log_backup_full
        rm -f $old_file_snar_backup_full

        #Проверка наличия двух полных бэкапов и удаление всех инкрементов не актуальных для этих полных бэкапов
        count_full_backup=$(ls $BACKUP_DIR_DATA | grep full | wc -l)
        if [[ $count_full_backup == $BACKUP_FULL_COUNT ]]; then
            old_file_backup_full=$(find $BACKUP_DIR_DATA -maxdepth 1 -type f -name '*full*' | sort -n | head -n 1)
            old_file_log_backup_full=$(find $BACKUP_DIR_DATA_LOG -maxdepth 1 -type f -name '*full*' | sort -n | head -n 1)
            remove_old_file_incr_or_log $old_file_backup_full $BACKUP_DIR_DATA
            remove_old_file_incr_or_log $old_file_log_backup_full $BACKUP_DIR_DATA_LOG
        fi
    fi
}

#Функция восстановления файлов
restore_data() {
    #Показать доступные бэкапы
    checkBackups=$(ls -1tr "$BACKUP_DIR_DATA" | grep -v log | grep -v snar)

    if [ -n "$checkBackups" ]; then
        i=1
        for backup in $checkBackups; do
            echo "$i) $backup"
            ((i++)) 2>/dev/null || i=$((i+1))  # Защита от ошибок
        done

        read -p "Введите дату восстановления (в формате 10112025): " restoreDate
        read -p "Введите название файла или его часть для поиска: " restoreData
    else
        echo "Нет доступных бэкапов"
        exit 1
    fi

    #Проверка наличия бэкапа по дате
    if [[ -z $(ls $BACKUP_DIR_DATA | grep "$restoreDate") ]]; then
        echo "Не найдено бэкапа за эту дату"
        exit 1
    fi

    #Создание массива из файлов бэкапов для его индексации
    mapfile -t files_sorted < <(
        find $BACKUP_DIR_DATA -maxdepth 1 -type f | while read -r file; do
            file_name=$(basename "$file")
            file_date=$(echo "$file_name" | awk -F'_' '{print $2}')
            echo "$file_date $file"
        done | sort -r
    )

    #Инициализация переменной
    local start_index=0

    #Поиск индекса бэкапа соответствующего дате поиска
    for i in "${!files_sorted[@]}"; do
            file_date=$(echo "${files_sorted[$i]}" | awk -F' ' '{print $1}')
            if [[ "$file_date" == "$restoreDate" ]]; then
                    start_index=$i
                    break
            fi
    done

    #Проверка что start_index был найден
    if [[ -z "$start_index" ]]; then
        echo "Не удалось найти начальный индекс для восстановления"
        exit 1
    fi

    #Перебор всех файлов массива до тех пор, пока не найдётся файл в инкременте или не дойдёт до полного бэкапа
    for ((i=start_index; i<${#files_sorted[@]}; i++)); do
            file_backup=$(echo "${files_sorted[$i]}" | awk -F' ' '{print $2}')
            
            #Процедура поиска файла внутри архивов
            checkFileInBackup=$(tar -tf "$file_backup" | grep -wi "$restoreData")

            if [[ -n "$checkFileInBackup" ]]; then
                for file_in_backup in $checkFileInBackup; do
                    tar -xf "$file_backup" -C "$RESTORE_STORAGE_DIR" "$file_in_backup"
                done

                if [ $? -eq 0 ]; then
                    echo "Данные восстановлены в папку $RESTORE_STORAGE_DIR"
                    return 0
                fi
            else
                echo "Данные для восстановления не найдены в $file_backup"
            fi

            #Проверка нахождения первого full
            if [[ "$file_backup" == *_full* ]]; then
                break
            fi
    done
    
    log "Восстановление не выполнено"
}

case $1 in
    "incr")
        log "Режим: Создание инкрементной резервной копии"

        log "Переданные параметры для выполнения инкрементного бэкапа:================="
        log "Директория для сохранения бэкапа: $BACKUP_STORAGE_DIR"
        log "Имя бэкапа: $BACKUP_STORAGE_NAME"
        log "Файл или директория, которую необходимо бэкапировать: $SOURCE_BACKUP"
        log "Количество точек для хранения полных бэкапов: $BACKUP_FULL_COUNT"
        log "Количество точек для хранения инкрементных бэкапов: $BACKUP_INCR_COUNT"

        #Создание директории бэкопирования если не существует
        dirsCheck=("$BACKUP_DIR_DATA" "$BACKUP_DIR_DATA_LOG" "$BACKUP_SNAR_DIR")
        for dir in ${dirsCheck[@]}; do
            if [ ! -d "$dir" ]; then
                mkdir -p $dir
            fi
        done

        backup_increment
        ;;
    
    "full")
        log "Режим: Создание полной резервной копии"

        log "Переданные параметры для выполнения полного бэкапа:================="
        log "Директория для сохранения бэкапа: $BACKUP_STORAGE_DIR"
        log "Имя бэкапа: $BACKUP_STORAGE_NAME"
        log "Файл или директория, которую необходимо бэкапировать: $SOURCE_BACKUP"
        log "Количество точек для хранения полных бэкапов: $BACKUP_FULL_COUNT"
        log "Количество точек для хранения инкрементных бэкапов: $BACKUP_INCR_COUNT"

        #Создание директории бэкопирования если не существует
        dirsCheck=("$BACKUP_DIR_DATA" "$BACKUP_DIR_DATA_LOG" "$BACKUP_SNAR_DIR")
        for dir in ${dirsCheck[@]}; do
            if [ ! -d "$dir" ]; then
                mkdir -p $dir
            fi
        done

        backup_full
        ;;
    
    "restore")
        log "Режим: Восстановление данных"

        log "Переданные параметры для выполнения восстановления:================="
        log "Директория хранения бэкапов: $BACKUP_STORAGE_DIR"
        log "Директория, в которую будут сохранены восстановленные файлы: $RESTORE_STORAGE_DIR"

        #Создание директории восстановления если не существует
        if [ ! -d "$RESTORE_STORAGE_DIR" ]; then
            mkdir -p "$RESTORE_STORAGE_DIR"
            log "Создана директория восстановления: $RESTORE_STORAGE_DIR"
        fi

        restore_data "$BACKUP_STORAGE_DIR" "$RESTORE_STORAGE_DIR"
        ;;

    *)
        log "Инструкция по использованию. Вызовите скрипт с нужными ключами..."
        show_help
        exit 1
        ;;
esac