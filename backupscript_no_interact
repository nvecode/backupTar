#!/bin/bash

#Переменные для бэкапа
BACKUP_STORAGE_DIR=$2
BACKUP_STORAGE_NAME=$3
SOURCE_BACKUP=$4
BACKUP_FULL_COUNT_POLICY=$5
BACKUP_INCR_COUNT_POLICY=$6

BACKUP_FULL_COUNT_POLICY=${BACKUP_FULL_COUNT_POLICY:-0}
BACKUP_INCR_COUNT_POLICY=${BACKUP_INCR_COUNT_POLICY:-0}

if [[ $BACKUP_FULL_COUNT_POLICY == 0 || $BACKUP_INCR_COUNT_POLICY == 0 ]]; then
    COUNT_RATION_INCR_FULL=0
else
    COUNT_RATION_INCR_FULL=$(( (BACKUP_INCR_COUNT_POLICY + BACKUP_FULL_COUNT_POLICY - 1) / BACKUP_FULL_COUNT_POLICY ))
fi

#Вычисление итого количество точек для полных и инкрементных копий
BACKUP_FULL_COUNT=$(( $BACKUP_FULL_COUNT_POLICY + 1 ))
BACKUP_INCR_COUNT=$(( $BACKUP_INCR_COUNT_POLICY + $COUNT_RATION_INCR_FULL ))

#Переменные для восстановления
RESTORE_STORAGE_DIR=$3

#=======================Неизменяемые поля=======================#
BACKUP_DIR_DATA=${BACKUP_STORAGE_DIR}/data
BACKUP_DIR_DATA_LOG=${BACKUP_STORAGE_DIR}/logs
BACKUP_SNAR_DIR=${BACKUP_STORAGE_DIR}/snar
BACKUP_DATE=$(date +'%d%m%Y')
BACKUP_TIME=$(date +'%H%M%S')
BACKUP_FILENAME=${BACKUP_STORAGE_NAME}_${BACKUP_DATE}_${BACKUP_TIME}

#Функция логирования
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

#Функция вывода информации по скрипту
show_help() {
    cat << EOF
Использование:
  ./backupscript incr <backup_storage_dir> <backup_storage_name> <source_backup> <backup_full_count> <backup_incr_count>
  ./backupscript full <backup_storage_dir> <backup_storage_name> <source_backup> <backup_full_count> <backup_incr_count>
  ./backupscript restore <backup_storage_dir> <destination_restore_data>
  ./backupscript show_files_in_backup <backup_storage_dir>

Параметры для резервного копирования:
  backup_storage_dir    - директория для хранения бэкапов
  backup_storage_name   - имя бэкапа
  source_backup         - директория для резервного копирования
  backup_full_count     - количество хранимых полных бэкапов (целое число)
  backup_incr_count     - количество хранимых инкрементальных бэкапов (целое число)

Параметры для восстановления:
  backup_storage_dir        - директория для хранения бэкапов
  destination_restore_data  - директория для восстановления

Примеры:
  ./backupscript incr /backups mybackup /home/user 3 5
  ./backupscript full /backups mybackup /home/user 3 5
  ./backupscript restore /backups /restored_data
  ./backupscript show_files_in_backup <backup_storage_dir>
EOF
}

#Функция поиска старых бэкапов или логов
search_old_backup_or_log() {
    #В функцию передаются: 1) Тип бэкапа: инкрементный или полный, 2) Тип файла: лог, бэкап или snar
    local typeBackup=$1
    local typeFile=$2
    local file_count=""
    local search_dir=""

    #Проверка на тип переданного файла и подсчёт количество файлов в директории
    if [ "$typeFile" == "backup" ]; then
        search_dir=$BACKUP_DIR_DATA
        file_count=$(ls $BACKUP_DIR_DATA | grep $typeBackup | wc -l)
    elif [ "$typeFile" == "log" ]; then
        search_dir=$BACKUP_DIR_DATA_LOG
        file_count=$(ls $BACKUP_DIR_DATA_LOG | grep $typeBackup | wc -l)
    elif [ "$typeFile" == "snar" ]; then
        search_dir=$BACKUP_SNAR_DIR
        file_count=$(ls $BACKUP_SNAR_DIR | grep $typeBackup | wc -l)
    fi

    #Если количество файлов больше 0, то для полного бэкапа вывести все нужные файлы
    if [ -n "$file_count" ]; then
        #Для FULL
        if [ "$typeBackup" == "full" ]; then
            if [ "$file_count" -gt $BACKUP_FULL_COUNT ]; then
                find $search_dir -maxdepth 1 -type f -name '*full*' | sort -n | head -n 1
            fi
        
        #Для INCR
        elif [ "$typeBackup" == "incr" ]; then
            if [ "$file_count" -gt $BACKUP_INCR_COUNT ]; then
                find $search_dir -maxdepth 1 -type f -name '*incr*' | sort -n | head -n 1
            fi
        
        #Для SNAR
        elif [ "$typeBackup" == "full" ]; then
            if [ "$file_count" -gt $BACKUP_FULL_COUNT ]; then
                find $search_dir -maxdepth 1 -type f -name '*$BACKUP_FILENAME*' | sort -n | head -n 1
            fi
        fi
    fi
}

#Функция удаления инкрементных файлов по времени модификации
remove_old_file_incr_or_log() {
    local old_file_backup_or_log=$1
    local folder_old_file_backup_or_log=$2

    # Получаем время модификации старого файла (в секундах с эпохи)
    old_file_mtime=$(stat -c %Y "$old_file_backup_or_log")
    
    # Удаляем инкрементные файлы, созданные раньше
    find "$folder_old_file_backup_or_log" -name "*incr*" -type f | while read -r incr_file; do
        file_mtime=$(stat -c %Y "$incr_file")
        if [ "$file_mtime" -lt "$old_file_mtime" ]; then
            echo "Удаляем: $(basename "$incr_file")"
            rm -f "$incr_file"
        fi
    done
}

#Просмотр файлов бэкапов в директории
show_dir_backup() {
    log "Просмотр файлов бэкапов в директории"

    checkBackups=$(ls -1tr "$BACKUP_DIR_DATA" | grep -v log | grep -v snar)

    if [ -n "$checkBackups" ]; then
        i=1
        for backup in $checkBackups; do
            echo "$i) $backup"
            ((i++)) 2>/dev/null || i=$((i+1))
        done
    fi
}

#Просмотр файлов внутри бэкапа
show_files_in_backup() {
    #Вызываем функцию просмотра файлов бэкапов в директории
    show_dir_backup

    if [ $? -eq 0 ]; then
        read -p "Введите дату (в формате 10112025): " data_backup
    else
        log "Нет доступных бэкапов"
        exit 1
    fi

    #Проверка наличия бэкапа по дате
    if [[ -z $(ls $BACKUP_DIR_DATA | grep "$data_backup") ]]; then
        log "Не найдено бэкапа за эту дату"
        exit 1
    fi

    # Запрос на просмотр содержимого архива
    read -p "Хотите просмотреть содержимое архива? (y/n): " view_content
    
    if [[ "$view_content" == "y" || "$view_content" == "Y" ]]; then
        # Создание массива из файлов бэкапов за указанную дату
        mapfile -t date_files < <(find $BACKUP_DIR_DATA -maxdepth 1 -type f -name "*${data_backup}*" | sort)
        
        if [ ${#date_files[@]} -eq 0 ]; then
            log "Нет файлов бэкапа за указанную дату"
            exit 1
        fi
        
        log "Доступные архивы за дату $data_backup:"
        for i in "${!date_files[@]}"; do
            echo "$((i+1))) $(basename "${date_files[$i]}")"
        done
        
        read -p "Выберите номер архива для просмотра (1-${#date_files[@]}): " archive_num
        
        if [[ "$archive_num" =~ ^[0-9]+$ ]] && [ "$archive_num" -ge 1 ] && [ "$archive_num" -le ${#date_files[@]} ]; then
            selected_archive="${date_files[$((archive_num-1))]}"
            log "Содержимое архива $(basename "$selected_archive"):"
            log "----------------------------------------"
            tar -tzf "$selected_archive"
        else
            log "Неверный номер архива"
        fi
    fi
}

#Функция создания инкрементных копий
backup_increment() {
    if [[ "$(ls $BACKUP_DIR_DATA | grep full | wc -l)" > 0 ]]; then
        #Проверка наличия последнего snar файла
        if [ -f "$BACKUP_SNAR_DIR/last_backup.snar" ]; then
            BACKUP_SNAR=$(cat "$BACKUP_SNAR_DIR/last_backup.snar")
        else
            log "Файл SNAR для последнего запущенного полного бэкапа не найден"
            exit 1
        fi
        
        #Выполнение инкрементного бэкапа
        tar -g $BACKUP_SNAR -czvf $BACKUP_DIR_DATA/${BACKUP_FILENAME}_incr.tar.gz -C $SOURCE_BACKUP . &>$BACKUP_DIR_DATA_LOG/${BACKUP_FILENAME}_incr.log
        if [ $? -eq 0 ]; then
            
            #Находим бэкап или файлы, старше нужных POINT - ДЛЯ ИНКРЕМЕНТНЫХ КОПИЙ
            old_file_backup_incr=$(search_old_backup_or_log incr backup)
            old_file_log_backup_incr=$(search_old_backup_or_log incr log)

            #Удаляем найденные файлы бэкап или логов - ДЛЯ ИНКРЕМЕНТНЫХ КОПИЙ
            rm -f $old_file_backup_incr
            rm -f $old_file_log_backup_incr
        fi
    else
        log "ERROR: Необходимо сначала выполнить полный бэкап"
        exit 1
    fi
}

#Функция создания полных копий
backup_full() {
    BACKUP_SNAR="$BACKUP_SNAR_DIR/${BACKUP_STORAGE_NAME}_${BACKUP_DATE}_${BACKUP_TIME}_full.snar"
    echo "$BACKUP_SNAR" > "$BACKUP_SNAR_DIR/last_backup.snar"
    
    #Выполнение полного бэкапа
    tar -g $BACKUP_SNAR -czvf $BACKUP_DIR_DATA/${BACKUP_FILENAME}_full.tar.gz -C $SOURCE_BACKUP . &>$BACKUP_DIR_DATA_LOG/${BACKUP_FILENAME}_full.log
    if [ $? -eq 0 ]; then

        #Находим бэкап или файлы, старше нужных POINT - ДЛЯ ПОЛНЫХ КОПИЙ
        old_file_backup_full=$(search_old_backup_or_log full backup)
        old_file_log_backup_full=$(search_old_backup_or_log full log)
        old_file_snar_backup_full=$(search_old_backup_or_log full snar)

        #Удаляем найденные файлы бэкап или логов - ДЛЯ ПОЛНЫХ КОПИЙ
        rm -f $old_file_backup_full
        rm -f $old_file_log_backup_full
        rm -f $old_file_snar_backup_full

        #Проверка наличия полных бэкапов и удаление всех инкрементов не актуальных для этих полных бэкапов
        count_full_backup=$(ls $BACKUP_DIR_DATA | grep full | wc -l)
        if [[ $count_full_backup == $BACKUP_FULL_COUNT ]]; then
            old_file_backup_full=$(find $BACKUP_DIR_DATA -maxdepth 1 -type f -name '*full*' | sort -n | head -n 1)
            old_file_log_backup_full=$(find $BACKUP_DIR_DATA_LOG -maxdepth 1 -type f -name '*full*' | sort -n | head -n 1)
            remove_old_file_incr_or_log $old_file_backup_full $BACKUP_DIR_DATA
            remove_old_file_incr_or_log $old_file_log_backup_full $BACKUP_DIR_DATA_LOG
        fi
    fi
}

#Функция восстановления файлов
restore_data() {
    #Вызываем функцию просмотра файлов в резервной копии
    show_files_in_backup

    read -p "Введите название файла или его часть для поиска и последующего восстановления: " restoreData

    #Создание массива из файлов бэкапов для его индексации
    mapfile -t files_sorted < <(
        find $BACKUP_DIR_DATA -maxdepth 1 -type f | while read -r file; do
            file_name=$(basename "$file")
            file_date=$(echo "$file_name" | awk -F'_' '{print $2}')
            echo "$file_date $file"
        done | sort -r
    )

    #Инициализация переменной
    local start_index=0

    #Поиск индекса бэкапа соответствующего дате поиска
    for i in "${!files_sorted[@]}"; do
            file_date=$(echo "${files_sorted[$i]}" | awk -F' ' '{print $1}')
            if [[ "$file_date" == "$data_backup" ]]; then
                    start_index=$i
                    break
            fi
    done

    #Проверка что start_index был найден
    if [[ -z "$start_index" ]]; then
        log "Не удалось найти начальный индекс для восстановления"
        exit 1
    fi

    #Перебор всех файлов массива до тех пор, пока не найдётся файл в инкременте или не дойдёт до полного бэкапа
    for ((i=start_index; i<${#files_sorted[@]}; i++)); do
            file_backup=$(echo "${files_sorted[$i]}" | awk -F' ' '{print $2}')
            
            # Проверяем существование архива
            if [ ! -f "$file_backup" ]; then
                log "Архив $file_backup не найден"
                return 1
            fi
            
            # Ищем файлы по шаблону в архиве
            tar -tzf "$file_backup" 2>/dev/null | grep -i "$search_pattern"
            if [ $? -ne 0 ]; then
                return 1
            fi

            if [ $? -eq 0 ]; then
                #Если нашли файл, извлекаем его
                checkFileInBackup=$(tar -tzf "$file_backup" | grep -wi "$restoreData")
                
                for file_in_backup in $checkFileInBackup; do
                    tar -xzf "$file_backup" -C "$RESTORE_STORAGE_DIR" "$file_in_backup"
                    if [ $? -eq 0 ]; then
                        log "Файл $file_in_backup восстановлен в папку $RESTORE_STORAGE_DIR"
                    else
                        log "Ошибка при восстановлении файла $file_in_backup"
                    fi
                done
                
                log "Восстановление завершено"
                return 0
            else
                log "Данные для восстановления не найдены в $(basename "$file_backup")"
            fi

            #Проверка нахождения первого full
            if [[ "$file_backup" == *_full* ]]; then
                break
            fi
    done
    
    log "Восстановление не выполнено - файлы не найдены"
    return 1
}

case $1 in
    "incr")
        log "Режим: Создание инкрементной резервной копии"

        log "Переданные параметры для выполнения инкрементного бэкапа:================="
        log "Директория для сохранения бэкапа: $BACKUP_STORAGE_DIR"
        log "Имя бэкапа: $BACKUP_STORAGE_NAME"
        log "Файл или директория, которую необходимо бэкапировать: $SOURCE_BACKUP"
        log "Количество точек для хранения полных бэкапов: $BACKUP_FULL_COUNT"
        log "Количество точек для хранения инкрементных бэкапов: $BACKUP_INCR_COUNT"

        #Создание директории бэкопирования если не существует
        dirsCheck=("$BACKUP_DIR_DATA" "$BACKUP_DIR_DATA_LOG" "$BACKUP_SNAR_DIR")
        for dir in ${dirsCheck[@]}; do
            if [ ! -d "$dir" ]; then
                mkdir -p $dir
            fi
        done

        backup_increment

        if [ $? -eq 0 ]; then
            log "SUCCESS: Инкрементный бэкап успешно создан"
        else
            log "ERROR: Произошла ошибка при создании инкреметного бэкапа"
        fi
        ;;
    
    "full")
        log "Режим: Создание полной резервной копии"

        log "Переданные параметры для выполнения полного бэкапа:================="
        log "Директория для сохранения бэкапа: $BACKUP_STORAGE_DIR"
        log "Имя бэкапа: $BACKUP_STORAGE_NAME"
        log "Файл или директория, которую необходимо бэкапировать: $SOURCE_BACKUP"
        log "Количество точек для хранения полных бэкапов: $BACKUP_FULL_COUNT"
        log "Количество точек для хранения инкрементных бэкапов: $BACKUP_INCR_COUNT"

        #Создание директории бэкопирования если не существует
        dirsCheck=("$BACKUP_DIR_DATA" "$BACKUP_DIR_DATA_LOG" "$BACKUP_SNAR_DIR")
        for dir in ${dirsCheck[@]}; do
            if [ ! -d "$dir" ]; then
                mkdir -p $dir
            fi
        done

        backup_full

        if [ $? -eq 0 ]; then
            log "SUCCESS: Полный бэкап успешно создан"
        else
            log "ERROR: Произошла ошибка при создании полного бэкапа"
        fi
        ;;
    
    "restore")
        log "Режим: Восстановление данных"

        log "Переданные параметры для выполнения восстановления:================="
        log "Директория хранения бэкапов: $BACKUP_STORAGE_DIR"
        log "Директория, в которую будут сохранены восстановленные файлы: $RESTORE_STORAGE_DIR"

        #Создание директории восстановления если не существует
        if [ ! -d "$RESTORE_STORAGE_DIR" ]; then
            mkdir -p "$RESTORE_STORAGE_DIR"
            log "Создана директория восстановления: $RESTORE_STORAGE_DIR"
        fi

        restore_data "$BACKUP_STORAGE_DIR" "$RESTORE_STORAGE_DIR"
        ;;
    
    "show_files_in_backup")
        log "Режим: Просмотр файлов внутри бэкапа"

        log "Переданные параметры для выполнения восстановления:================="
        log "Директория хранения бэкапов: $BACKUP_STORAGE_DIR"
    
        show_files_in_backup
        ;;
    *)
        log "Инструкция по использованию. Вызовите скрипт с нужными ключами..."
        show_help
        exit 1
        ;;
esac